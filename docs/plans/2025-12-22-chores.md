# Chores Feature Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a chores display and completion interface for family members to view and complete household tasks.

**Architecture:** Read-only chores view with single-tap completion. Chores are scoped to families, assigned to members, support recurrence patterns, and track completion with star rewards. The UI shows a progress card, filter tabs (All/By Person/Urgent), and chore cards with check buttons.

**Tech Stack:** Next.js 16, Drizzle ORM, PostgreSQL, React 19, Tailwind CSS, shadcn/ui, Zod validation

---

## Phase 1: Database Schema

### Task 1: Add Chores Table to Schema

**Files:**
- Modify: `src/server/schema.ts`

**Step 1: Add the chores table definition**

Add after the Reward Charts section (around line 213):

```typescript
// ============================================================================
// Chores
// ============================================================================

/**
 * Chores table - Household tasks assigned to family members
 */
export const chores = pgTable("chores", {
  id: text("id").primaryKey(),
  familyId: text("family_id")
    .notNull()
    .references(() => families.id, { onDelete: "cascade" }),
  title: text("title").notNull(),
  description: text("description"),
  assignedToId: text("assigned_to_id").references(() => familyMembers.id, {
    onDelete: "set null",
  }),
  dueDate: date("due_date", { mode: "string" }),
  dueTime: text("due_time"), // HH:mm format
  recurrence: text("recurrence").notNull().default("once"), // once | daily | weekly | weekdays | weekends | monthly
  isUrgent: boolean("is_urgent").notNull().default(false),
  status: text("status").notNull().default("pending"), // pending | completed | skipped
  starReward: integer("star_reward").notNull().default(10),
  completedAt: timestamp("completed_at", { mode: "date" }),
  completedById: text("completed_by_id").references(() => familyMembers.id, {
    onDelete: "set null",
  }),
  createdAt: timestamp("created_at", { mode: "date" }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { mode: "date" }).notNull().defaultNow(),
});
```

**Step 2: Add chores relations**

Add after existing relations:

```typescript
export const choresRelations = relations(chores, ({ one }) => ({
  family: one(families, {
    fields: [chores.familyId],
    references: [families.id],
  }),
  assignedTo: one(familyMembers, {
    fields: [chores.assignedToId],
    references: [familyMembers.id],
    relationName: "assignedChores",
  }),
  completedBy: one(familyMembers, {
    fields: [chores.completedById],
    references: [familyMembers.id],
    relationName: "completedChores",
  }),
}));
```

**Step 3: Add type exports**

Add at the end of the file:

```typescript
export type Chore = typeof chores.$inferSelect;
export type NewChore = typeof chores.$inferInsert;
```

**Step 4: Generate migration**

Run: `pnpm db:generate`
Expected: New migration file created in `drizzle/` folder

**Step 5: Run migration**

Run: `pnpm db:migrate`
Expected: Migration applied successfully

**Step 6: Commit**

```bash
git add src/server/schema.ts drizzle/
git commit -m "feat(chores): add database schema"
```

---

## Phase 2: Type Definitions

### Task 2: Create Chore Types

**Files:**
- Create: `src/types/chore.ts`

**Step 1: Create the types file**

```typescript
import type { FamilyMemberWithUser } from "./family";

// =============================================================================
// Enums
// =============================================================================

export type ChoreStatus = "pending" | "completed" | "skipped";
export type ChoreRecurrence =
  | "once"
  | "daily"
  | "weekly"
  | "weekdays"
  | "weekends"
  | "monthly";
export type UrgencyStatus = "none" | "due-soon" | "urgent" | "overdue";

export const CHORE_STATUSES: ChoreStatus[] = ["pending", "completed", "skipped"];
export const CHORE_RECURRENCES: ChoreRecurrence[] = [
  "once",
  "daily",
  "weekly",
  "weekdays",
  "weekends",
  "monthly",
];

// =============================================================================
// Interfaces
// =============================================================================

export interface IChore {
  id: string;
  familyId: string;
  title: string;
  description: string | null;
  assignedToId: string | null;
  dueDate: string | null; // YYYY-MM-DD
  dueTime: string | null; // HH:mm
  recurrence: ChoreRecurrence;
  isUrgent: boolean;
  status: ChoreStatus;
  starReward: number;
  completedAt: Date | null;
  completedById: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface IChoreWithAssignee extends IChore {
  assignedTo: FamilyMemberWithUser | null;
  completedBy: FamilyMemberWithUser | null;
}

export interface IChoreProgress {
  completed: number;
  total: number;
  percentage: number;
}

export interface IChoreStreak {
  currentStreak: number;
  longestStreak: number;
  lastCompletedDate: string | null;
}

// =============================================================================
// Filter Types
// =============================================================================

export type ChoreViewFilter = "all" | "by-person" | "urgent";

export interface ChoreFilters {
  status?: ChoreStatus;
  assignedToIds?: string[];
  isUrgent?: boolean;
  startDate?: string;
  endDate?: string;
}
```

**Step 2: Export from types index**

Add to `src/types/index.ts` (create if doesn't exist):

```typescript
export * from "./chore";
export * from "./family";
```

**Step 3: Commit**

```bash
git add src/types/
git commit -m "feat(chores): add type definitions"
```

---

## Phase 3: Validation Schemas

### Task 3: Create Chore Validation Schemas

**Files:**
- Create: `src/lib/validations/chore.ts`

**Step 1: Create the validation file**

```typescript
import { z } from "zod";

// =============================================================================
// Enums
// =============================================================================

export const choreStatusSchema = z.enum(["pending", "completed", "skipped"]);
export const choreRecurrenceSchema = z.enum([
  "once",
  "daily",
  "weekly",
  "weekdays",
  "weekends",
  "monthly",
]);

// =============================================================================
// Input Schemas
// =============================================================================

export const createChoreSchema = z.object({
  title: z.string().min(1, "Title is required").max(255),
  description: z.string().max(2000).nullable().optional(),
  assignedToId: z.string().min(1).nullable().optional(),
  dueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Invalid date format").nullable().optional(),
  dueTime: z.string().regex(/^\d{2}:\d{2}$/, "Invalid time format (HH:mm)").nullable().optional(),
  recurrence: choreRecurrenceSchema.default("once"),
  isUrgent: z.boolean().default(false),
  starReward: z.number().int().min(0).max(1000).default(10),
});

export const updateChoreSchema = createChoreSchema.partial();

export const choreQuerySchema = z.object({
  status: choreStatusSchema.optional(),
  assignedToIds: z.array(z.string()).optional(),
  isUrgent: z.coerce.boolean().optional(),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
});

export const completeChoreSchema = z.object({
  completedById: z.string().min(1, "Completer ID is required"),
});

// =============================================================================
// Type Exports
// =============================================================================

export type CreateChoreInput = z.infer<typeof createChoreSchema>;
export type UpdateChoreInput = z.infer<typeof updateChoreSchema>;
export type ChoreQueryInput = z.infer<typeof choreQuerySchema>;
export type CompleteChoreInput = z.infer<typeof completeChoreSchema>;
```

**Step 2: Commit**

```bash
git add src/lib/validations/chore.ts
git commit -m "feat(chores): add validation schemas"
```

---

## Phase 4: Service Layer

### Task 4: Create Chore Service

**Files:**
- Create: `src/server/services/chore-service.ts`

**Step 1: Create the service file with imports and types**

```typescript
import { db } from "@/server/db";
import { chores, familyMembers, users } from "@/server/schema";
import { eq, and, gte, lte, desc, asc, isNull, or } from "drizzle-orm";
import { createId } from "@paralleldrive/cuid2";
import type {
  CreateChoreInput,
  UpdateChoreInput,
  ChoreQueryInput,
} from "@/lib/validations/chore";
import type { IChoreWithAssignee } from "@/types/chore";

// =============================================================================
// HELPER: Build chore with assignee from row
// =============================================================================

function buildChoreWithAssignee(row: {
  chore: typeof chores.$inferSelect;
  assignedMember: typeof familyMembers.$inferSelect | null;
  assignedUser: typeof users.$inferSelect | null;
  completedMember: typeof familyMembers.$inferSelect | null;
  completedUser: typeof users.$inferSelect | null;
}): IChoreWithAssignee {
  return {
    ...row.chore,
    recurrence: row.chore.recurrence as IChoreWithAssignee["recurrence"],
    status: row.chore.status as IChoreWithAssignee["status"],
    assignedTo:
      row.assignedMember && row.assignedUser
        ? {
            id: row.assignedMember.id,
            familyId: row.assignedMember.familyId,
            userId: row.assignedMember.userId,
            role: row.assignedMember.role as "manager" | "participant" | "caregiver",
            displayName: row.assignedMember.displayName,
            avatarColor: row.assignedMember.avatarColor,
            createdAt: row.assignedMember.createdAt,
            user: {
              id: row.assignedUser.id,
              name: row.assignedUser.name,
              email: row.assignedUser.email,
              image: row.assignedUser.image,
            },
          }
        : null,
    completedBy:
      row.completedMember && row.completedUser
        ? {
            id: row.completedMember.id,
            familyId: row.completedMember.familyId,
            userId: row.completedMember.userId,
            role: row.completedMember.role as "manager" | "participant" | "caregiver",
            displayName: row.completedMember.displayName,
            avatarColor: row.completedMember.avatarColor,
            createdAt: row.completedMember.createdAt,
            user: {
              id: row.completedUser.id,
              name: row.completedUser.name,
              email: row.completedUser.email,
              image: row.completedUser.image,
            },
          }
        : null,
  };
}
```

**Step 2: Add query functions**

```typescript
// =============================================================================
// QUERY OPERATIONS
// =============================================================================

/**
 * Alias tables for multiple joins to same table
 */
const assignedMembers = familyMembers;
const completedMembers = familyMembers;
const assignedUsers = users;
const completedUsers = users;

/**
 * Get all chores for a family with optional filters
 */
export async function getChoresForFamily(
  familyId: string,
  query?: ChoreQueryInput
): Promise<IChoreWithAssignee[]> {
  const conditions = [eq(chores.familyId, familyId)];

  if (query?.status) {
    conditions.push(eq(chores.status, query.status));
  }
  if (query?.isUrgent !== undefined) {
    conditions.push(eq(chores.isUrgent, query.isUrgent));
  }
  if (query?.startDate) {
    conditions.push(
      or(gte(chores.dueDate, query.startDate), isNull(chores.dueDate))!
    );
  }
  if (query?.endDate) {
    conditions.push(
      or(lte(chores.dueDate, query.endDate), isNull(chores.dueDate))!
    );
  }

  const rows = await db
    .select({
      chore: chores,
      assignedMember: assignedMembers,
      assignedUser: assignedUsers,
      completedMember: completedMembers,
      completedUser: completedUsers,
    })
    .from(chores)
    .leftJoin(assignedMembers, eq(chores.assignedToId, assignedMembers.id))
    .leftJoin(assignedUsers, eq(assignedMembers.userId, assignedUsers.id))
    .leftJoin(completedMembers, eq(chores.completedById, completedMembers.id))
    .leftJoin(completedUsers, eq(completedMembers.userId, completedUsers.id))
    .where(and(...conditions))
    .orderBy(asc(chores.dueDate), asc(chores.dueTime), asc(chores.createdAt));

  let result = rows.map(buildChoreWithAssignee);

  // Filter by assignedToIds in memory (complex OR query)
  if (query?.assignedToIds && query.assignedToIds.length > 0) {
    result = result.filter(
      (c) => c.assignedToId && query.assignedToIds!.includes(c.assignedToId)
    );
  }

  return result;
}

/**
 * Get a single chore by ID
 */
export async function getChoreById(
  choreId: string,
  familyId: string
): Promise<IChoreWithAssignee | null> {
  const rows = await db
    .select({
      chore: chores,
      assignedMember: assignedMembers,
      assignedUser: assignedUsers,
      completedMember: completedMembers,
      completedUser: completedUsers,
    })
    .from(chores)
    .leftJoin(assignedMembers, eq(chores.assignedToId, assignedMembers.id))
    .leftJoin(assignedUsers, eq(assignedMembers.userId, assignedUsers.id))
    .leftJoin(completedMembers, eq(chores.completedById, completedMembers.id))
    .leftJoin(completedUsers, eq(completedMembers.userId, completedUsers.id))
    .where(and(eq(chores.id, choreId), eq(chores.familyId, familyId)))
    .limit(1);

  if (rows.length === 0) return null;
  return buildChoreWithAssignee(rows[0]);
}
```

**Step 3: Add mutation functions**

```typescript
// =============================================================================
// MUTATION OPERATIONS
// =============================================================================

/**
 * Create a new chore
 */
export async function createChore(
  familyId: string,
  input: CreateChoreInput
): Promise<IChoreWithAssignee> {
  const choreId = createId();
  const now = new Date();

  await db.insert(chores).values({
    id: choreId,
    familyId,
    title: input.title,
    description: input.description ?? null,
    assignedToId: input.assignedToId ?? null,
    dueDate: input.dueDate ?? null,
    dueTime: input.dueTime ?? null,
    recurrence: input.recurrence ?? "once",
    isUrgent: input.isUrgent ?? false,
    status: "pending",
    starReward: input.starReward ?? 10,
    createdAt: now,
    updatedAt: now,
  });

  const chore = await getChoreById(choreId, familyId);
  if (!chore) throw new Error("Failed to create chore");
  return chore;
}

/**
 * Update an existing chore
 */
export async function updateChore(
  choreId: string,
  familyId: string,
  input: UpdateChoreInput
): Promise<IChoreWithAssignee> {
  const existing = await getChoreById(choreId, familyId);
  if (!existing) throw new Error("Chore not found");

  const updates: Record<string, unknown> = { updatedAt: new Date() };

  if (input.title !== undefined) updates.title = input.title;
  if (input.description !== undefined) updates.description = input.description;
  if (input.assignedToId !== undefined) updates.assignedToId = input.assignedToId;
  if (input.dueDate !== undefined) updates.dueDate = input.dueDate;
  if (input.dueTime !== undefined) updates.dueTime = input.dueTime;
  if (input.recurrence !== undefined) updates.recurrence = input.recurrence;
  if (input.isUrgent !== undefined) updates.isUrgent = input.isUrgent;
  if (input.starReward !== undefined) updates.starReward = input.starReward;

  await db.update(chores).set(updates).where(eq(chores.id, choreId));

  const chore = await getChoreById(choreId, familyId);
  if (!chore) throw new Error("Failed to update chore");
  return chore;
}

/**
 * Delete a chore
 */
export async function deleteChore(choreId: string, familyId: string): Promise<void> {
  const existing = await getChoreById(choreId, familyId);
  if (!existing) throw new Error("Chore not found");

  await db.delete(chores).where(eq(chores.id, choreId));
}

/**
 * Complete a chore
 */
export async function completeChore(
  choreId: string,
  familyId: string,
  completedById: string
): Promise<IChoreWithAssignee> {
  const existing = await getChoreById(choreId, familyId);
  if (!existing) throw new Error("Chore not found");
  if (existing.status === "completed") throw new Error("Chore already completed");

  await db
    .update(chores)
    .set({
      status: "completed",
      completedAt: new Date(),
      completedById,
      updatedAt: new Date(),
    })
    .where(eq(chores.id, choreId));

  const chore = await getChoreById(choreId, familyId);
  if (!chore) throw new Error("Failed to complete chore");
  return chore;
}

/**
 * Undo chore completion
 */
export async function undoChoreCompletion(
  choreId: string,
  familyId: string
): Promise<IChoreWithAssignee> {
  const existing = await getChoreById(choreId, familyId);
  if (!existing) throw new Error("Chore not found");
  if (existing.status !== "completed") throw new Error("Chore is not completed");

  await db
    .update(chores)
    .set({
      status: "pending",
      completedAt: null,
      completedById: null,
      updatedAt: new Date(),
    })
    .where(eq(chores.id, choreId));

  const chore = await getChoreById(choreId, familyId);
  if (!chore) throw new Error("Failed to undo completion");
  return chore;
}
```

**Step 4: Add progress functions**

```typescript
// =============================================================================
// PROGRESS OPERATIONS
// =============================================================================

/**
 * Get today's chore progress for a family
 */
export async function getChoreProgress(
  familyId: string,
  date?: string
): Promise<{ completed: number; total: number; percentage: number }> {
  const targetDate = date ?? new Date().toISOString().split("T")[0];

  // Get all pending chores due today or earlier, plus completed today
  const allChores = await db
    .select()
    .from(chores)
    .where(eq(chores.familyId, familyId));

  const relevantChores = allChores.filter((c) => {
    // Include if completed today
    if (c.status === "completed" && c.completedAt) {
      const completedDate = c.completedAt.toISOString().split("T")[0];
      return completedDate === targetDate;
    }
    // Include if pending and due today or earlier (or no due date for daily tasks)
    if (c.status === "pending") {
      if (!c.dueDate) return c.recurrence !== "once"; // Recurring without date
      return c.dueDate <= targetDate;
    }
    return false;
  });

  const completed = relevantChores.filter((c) => c.status === "completed").length;
  const total = relevantChores.length;
  const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

  return { completed, total, percentage };
}
```

**Step 5: Commit**

```bash
git add src/server/services/chore-service.ts
git commit -m "feat(chores): add service layer"
```

---

## Phase 5: API Routes

### Task 5: Create Chores List API Route

**Files:**
- Create: `src/app/api/v1/families/[familyId]/chores/route.ts`

**Step 1: Create the route file**

```typescript
import { NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/server/auth";
import { isUserFamilyMember, isUserFamilyManager } from "@/server/services/family-service";
import { getChoresForFamily, createChore } from "@/server/services/chore-service";
import { createChoreSchema, choreQuerySchema } from "@/lib/validations/chore";

type Params = { params: Promise<{ familyId: string }> };

export async function GET(request: Request, { params }: Params) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: { code: "UNAUTHORIZED", message: "Not authenticated" } },
        { status: 401 }
      );
    }

    const { familyId } = await params;

    const isMember = await isUserFamilyMember(session.user.id, familyId);
    if (!isMember) {
      return NextResponse.json(
        { success: false, error: { code: "FORBIDDEN", message: "Not a family member" } },
        { status: 403 }
      );
    }

    const url = new URL(request.url);
    const queryParams = {
      status: url.searchParams.get("status") ?? undefined,
      isUrgent: url.searchParams.get("isUrgent") ?? undefined,
      startDate: url.searchParams.get("startDate") ?? undefined,
      endDate: url.searchParams.get("endDate") ?? undefined,
      assignedToIds: url.searchParams.getAll("assignedToIds"),
    };

    const parsed = choreQuerySchema.safeParse(queryParams);
    if (!parsed.success) {
      return NextResponse.json(
        { success: false, error: { code: "VALIDATION_ERROR", message: parsed.error.message } },
        { status: 400 }
      );
    }

    const chores = await getChoresForFamily(familyId, parsed.data);

    return NextResponse.json({ success: true, data: { chores } });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to fetch chores";
    return NextResponse.json(
      { success: false, error: { code: "INTERNAL_ERROR", message } },
      { status: 500 }
    );
  }
}

export async function POST(request: Request, { params }: Params) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: { code: "UNAUTHORIZED", message: "Not authenticated" } },
        { status: 401 }
      );
    }

    const { familyId } = await params;

    const isManager = await isUserFamilyManager(session.user.id, familyId);
    if (!isManager) {
      return NextResponse.json(
        { success: false, error: { code: "FORBIDDEN", message: "Only managers can create chores" } },
        { status: 403 }
      );
    }

    const body = await request.json();
    const parsed = createChoreSchema.safeParse(body);
    if (!parsed.success) {
      return NextResponse.json(
        { success: false, error: { code: "VALIDATION_ERROR", message: parsed.error.message } },
        { status: 400 }
      );
    }

    const chore = await createChore(familyId, parsed.data);

    return NextResponse.json({ success: true, data: { chore } }, { status: 201 });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to create chore";
    return NextResponse.json(
      { success: false, error: { code: "INTERNAL_ERROR", message } },
      { status: 500 }
    );
  }
}
```

**Step 2: Commit**

```bash
git add src/app/api/v1/families/\[familyId\]/chores/route.ts
git commit -m "feat(chores): add list and create API routes"
```

---

### Task 6: Create Single Chore API Route

**Files:**
- Create: `src/app/api/v1/families/[familyId]/chores/[choreId]/route.ts`

**Step 1: Create the route file**

```typescript
import { NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/server/auth";
import { isUserFamilyMember, isUserFamilyManager } from "@/server/services/family-service";
import { getChoreById, updateChore, deleteChore } from "@/server/services/chore-service";
import { updateChoreSchema } from "@/lib/validations/chore";

type Params = { params: Promise<{ familyId: string; choreId: string }> };

export async function GET(_request: Request, { params }: Params) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: { code: "UNAUTHORIZED", message: "Not authenticated" } },
        { status: 401 }
      );
    }

    const { familyId, choreId } = await params;

    const isMember = await isUserFamilyMember(session.user.id, familyId);
    if (!isMember) {
      return NextResponse.json(
        { success: false, error: { code: "FORBIDDEN", message: "Not a family member" } },
        { status: 403 }
      );
    }

    const chore = await getChoreById(choreId, familyId);
    if (!chore) {
      return NextResponse.json(
        { success: false, error: { code: "NOT_FOUND", message: "Chore not found" } },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: { chore } });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to fetch chore";
    return NextResponse.json(
      { success: false, error: { code: "INTERNAL_ERROR", message } },
      { status: 500 }
    );
  }
}

export async function PATCH(request: Request, { params }: Params) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: { code: "UNAUTHORIZED", message: "Not authenticated" } },
        { status: 401 }
      );
    }

    const { familyId, choreId } = await params;

    const isManager = await isUserFamilyManager(session.user.id, familyId);
    if (!isManager) {
      return NextResponse.json(
        { success: false, error: { code: "FORBIDDEN", message: "Only managers can update chores" } },
        { status: 403 }
      );
    }

    const body = await request.json();
    const parsed = updateChoreSchema.safeParse(body);
    if (!parsed.success) {
      return NextResponse.json(
        { success: false, error: { code: "VALIDATION_ERROR", message: parsed.error.message } },
        { status: 400 }
      );
    }

    const chore = await updateChore(choreId, familyId, parsed.data);

    return NextResponse.json({ success: true, data: { chore } });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to update chore";
    return NextResponse.json(
      { success: false, error: { code: "INTERNAL_ERROR", message } },
      { status: 500 }
    );
  }
}

export async function DELETE(_request: Request, { params }: Params) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: { code: "UNAUTHORIZED", message: "Not authenticated" } },
        { status: 401 }
      );
    }

    const { familyId, choreId } = await params;

    const isManager = await isUserFamilyManager(session.user.id, familyId);
    if (!isManager) {
      return NextResponse.json(
        { success: false, error: { code: "FORBIDDEN", message: "Only managers can delete chores" } },
        { status: 403 }
      );
    }

    await deleteChore(choreId, familyId);

    return NextResponse.json({ success: true, data: { deleted: true } });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to delete chore";
    return NextResponse.json(
      { success: false, error: { code: "INTERNAL_ERROR", message } },
      { status: 500 }
    );
  }
}
```

**Step 2: Commit**

```bash
git add src/app/api/v1/families/\[familyId\]/chores/\[choreId\]/route.ts
git commit -m "feat(chores): add single chore CRUD routes"
```

---

### Task 7: Create Complete Chore API Route

**Files:**
- Create: `src/app/api/v1/families/[familyId]/chores/[choreId]/complete/route.ts`

**Step 1: Create the route file**

```typescript
import { NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/server/auth";
import { isUserFamilyMember, getFamilyMemberByUserId } from "@/server/services/family-service";
import { completeChore, undoChoreCompletion } from "@/server/services/chore-service";

type Params = { params: Promise<{ familyId: string; choreId: string }> };

export async function POST(_request: Request, { params }: Params) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: { code: "UNAUTHORIZED", message: "Not authenticated" } },
        { status: 401 }
      );
    }

    const { familyId, choreId } = await params;

    const isMember = await isUserFamilyMember(session.user.id, familyId);
    if (!isMember) {
      return NextResponse.json(
        { success: false, error: { code: "FORBIDDEN", message: "Not a family member" } },
        { status: 403 }
      );
    }

    // Get the current user's family member ID
    const member = await getFamilyMemberByUserId(session.user.id, familyId);
    if (!member) {
      return NextResponse.json(
        { success: false, error: { code: "FORBIDDEN", message: "Member not found" } },
        { status: 403 }
      );
    }

    const chore = await completeChore(choreId, familyId, member.id);

    return NextResponse.json({
      success: true,
      data: { chore, starsEarned: chore.starReward },
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to complete chore";
    return NextResponse.json(
      { success: false, error: { code: "INTERNAL_ERROR", message } },
      { status: 500 }
    );
  }
}

export async function DELETE(_request: Request, { params }: Params) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: { code: "UNAUTHORIZED", message: "Not authenticated" } },
        { status: 401 }
      );
    }

    const { familyId, choreId } = await params;

    const isMember = await isUserFamilyMember(session.user.id, familyId);
    if (!isMember) {
      return NextResponse.json(
        { success: false, error: { code: "FORBIDDEN", message: "Not a family member" } },
        { status: 403 }
      );
    }

    const chore = await undoChoreCompletion(choreId, familyId);

    return NextResponse.json({ success: true, data: { chore } });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to undo completion";
    return NextResponse.json(
      { success: false, error: { code: "INTERNAL_ERROR", message } },
      { status: 500 }
    );
  }
}
```

**Step 2: Commit**

```bash
git add src/app/api/v1/families/\[familyId\]/chores/\[choreId\]/complete/route.ts
git commit -m "feat(chores): add completion toggle routes"
```

---

### Task 8: Create Progress API Route

**Files:**
- Create: `src/app/api/v1/families/[familyId]/chores/progress/route.ts`

**Step 1: Create the route file**

```typescript
import { NextResponse } from "next/server";
import { headers } from "next/headers";
import { auth } from "@/server/auth";
import { isUserFamilyMember } from "@/server/services/family-service";
import { getChoreProgress } from "@/server/services/chore-service";

type Params = { params: Promise<{ familyId: string }> };

export async function GET(request: Request, { params }: Params) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: { code: "UNAUTHORIZED", message: "Not authenticated" } },
        { status: 401 }
      );
    }

    const { familyId } = await params;

    const isMember = await isUserFamilyMember(session.user.id, familyId);
    if (!isMember) {
      return NextResponse.json(
        { success: false, error: { code: "FORBIDDEN", message: "Not a family member" } },
        { status: 403 }
      );
    }

    const url = new URL(request.url);
    const date = url.searchParams.get("date") ?? undefined;

    const progress = await getChoreProgress(familyId, date);

    return NextResponse.json({ success: true, data: { progress } });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to fetch progress";
    return NextResponse.json(
      { success: false, error: { code: "INTERNAL_ERROR", message } },
      { status: 500 }
    );
  }
}
```

**Step 2: Commit**

```bash
git add src/app/api/v1/families/\[familyId\]/chores/progress/route.ts
git commit -m "feat(chores): add progress API route"
```

---

## Phase 6: UI Components

### Task 9: Create Chores Context

**Files:**
- Create: `src/components/chores/contexts/chores-context.tsx`

**Step 1: Create the context file**

```typescript
"use client";

import { createContext, useContext, useState, useCallback } from "react";
import type { IChoreWithAssignee, IChoreProgress, ChoreViewFilter } from "@/types/chore";
import type { FamilyMemberWithUser } from "@/types/family";

interface ChoresContextValue {
  chores: IChoreWithAssignee[];
  members: FamilyMemberWithUser[];
  progress: IChoreProgress;
  currentView: ChoreViewFilter;
  setCurrentView: (view: ChoreViewFilter) => void;
  completeChore: (choreId: string) => Promise<void>;
  refreshChores: () => Promise<void>;
  isLoading: boolean;
}

const ChoresContext = createContext<ChoresContextValue | null>(null);

interface ChoresProviderProps {
  children: React.ReactNode;
  familyId: string;
  initialChores: IChoreWithAssignee[];
  initialProgress: IChoreProgress;
  members: FamilyMemberWithUser[];
}

export function ChoresProvider({
  children,
  familyId,
  initialChores,
  initialProgress,
  members,
}: ChoresProviderProps) {
  const [chores, setChores] = useState<IChoreWithAssignee[]>(initialChores);
  const [progress, setProgress] = useState<IChoreProgress>(initialProgress);
  const [currentView, setCurrentView] = useState<ChoreViewFilter>("all");
  const [isLoading, setIsLoading] = useState(false);

  const refreshChores = useCallback(async () => {
    setIsLoading(true);
    try {
      const [choresRes, progressRes] = await Promise.all([
        fetch(`/api/v1/families/${familyId}/chores?status=pending`),
        fetch(`/api/v1/families/${familyId}/chores/progress`),
      ]);

      if (choresRes.ok) {
        const data = await choresRes.json();
        setChores(data.data.chores);
      }
      if (progressRes.ok) {
        const data = await progressRes.json();
        setProgress(data.data.progress);
      }
    } finally {
      setIsLoading(false);
    }
  }, [familyId]);

  const completeChore = useCallback(
    async (choreId: string) => {
      // Optimistic update
      setChores((prev) => prev.filter((c) => c.id !== choreId));
      setProgress((prev) => ({
        completed: prev.completed + 1,
        total: prev.total,
        percentage: Math.round(((prev.completed + 1) / prev.total) * 100),
      }));

      try {
        const res = await fetch(
          `/api/v1/families/${familyId}/chores/${choreId}/complete`,
          { method: "POST" }
        );

        if (!res.ok) {
          // Revert on error
          await refreshChores();
        }
      } catch {
        await refreshChores();
      }
    },
    [familyId, refreshChores]
  );

  const value: ChoresContextValue = {
    chores,
    members,
    progress,
    currentView,
    setCurrentView,
    completeChore,
    refreshChores,
    isLoading,
  };

  return (
    <ChoresContext.Provider value={value}>{children}</ChoresContext.Provider>
  );
}

export function useChores(): ChoresContextValue {
  const context = useContext(ChoresContext);
  if (!context) {
    throw new Error("useChores must be used within a ChoresProvider");
  }
  return context;
}
```

**Step 2: Commit**

```bash
git add src/components/chores/
git commit -m "feat(chores): add ChoresProvider context"
```

---

### Task 10: Create Chore Helper Functions

**Files:**
- Create: `src/components/chores/helpers.ts`

**Step 1: Create the helpers file**

```typescript
import type { IChoreWithAssignee, UrgencyStatus } from "@/types/chore";

/**
 * Calculate urgency status for a chore
 */
export function getUrgencyStatus(chore: IChoreWithAssignee): UrgencyStatus {
  if (chore.status !== "pending") return "none";
  if (chore.isUrgent) return "urgent";
  if (!chore.dueDate) return "none";

  const now = new Date();
  const today = now.toISOString().split("T")[0];

  // Combine date and time for comparison
  let dueDateTime: Date;
  if (chore.dueTime) {
    dueDateTime = new Date(`${chore.dueDate}T${chore.dueTime}:00`);
  } else {
    dueDateTime = new Date(`${chore.dueDate}T23:59:59`);
  }

  if (dueDateTime < now) return "overdue";

  // Due within 4 hours
  const fourHoursLater = new Date(now.getTime() + 4 * 60 * 60 * 1000);
  if (dueDateTime < fourHoursLater) return "due-soon";

  return "none";
}

/**
 * Sort chores by priority
 * 1. Overdue (oldest first)
 * 2. Urgent (soonest first)
 * 3. Today (by time)
 * 4. Future (by date)
 * 5. Flexible (alphabetically)
 */
export function sortChores(chores: IChoreWithAssignee[]): IChoreWithAssignee[] {
  return [...chores].sort((a, b) => {
    const urgencyA = getUrgencyStatus(a);
    const urgencyB = getUrgencyStatus(b);

    // Priority order
    const urgencyOrder: Record<UrgencyStatus, number> = {
      overdue: 0,
      urgent: 1,
      "due-soon": 2,
      none: 3,
    };

    const orderDiff = urgencyOrder[urgencyA] - urgencyOrder[urgencyB];
    if (orderDiff !== 0) return orderDiff;

    // Same urgency: sort by date/time
    if (a.dueDate && b.dueDate) {
      const dateDiff = a.dueDate.localeCompare(b.dueDate);
      if (dateDiff !== 0) return dateDiff;

      if (a.dueTime && b.dueTime) {
        return a.dueTime.localeCompare(b.dueTime);
      }
    }

    // No date or same date: alphabetically
    return a.title.localeCompare(b.title);
  });
}

/**
 * Group chores by assignee
 */
export function groupChoresByAssignee(
  chores: IChoreWithAssignee[]
): Map<string, IChoreWithAssignee[]> {
  const groups = new Map<string, IChoreWithAssignee[]>();

  for (const chore of chores) {
    const key = chore.assignedToId ?? "unassigned";
    const existing = groups.get(key) ?? [];
    groups.set(key, [...existing, chore]);
  }

  return groups;
}

/**
 * Filter urgent chores
 */
export function getUrgentChores(chores: IChoreWithAssignee[]): IChoreWithAssignee[] {
  return chores.filter((c) => {
    const status = getUrgencyStatus(c);
    return status === "urgent" || status === "overdue" || status === "due-soon";
  });
}

/**
 * Format due date/time for display
 */
export function formatDueLabel(chore: IChoreWithAssignee): string | null {
  if (chore.recurrence !== "once") {
    const labels: Record<string, string> = {
      daily: "DAILY",
      weekly: "WEEKLY",
      weekdays: "WEEKDAYS",
      weekends: "WEEKEND",
      monthly: "MONTHLY",
    };
    return labels[chore.recurrence] ?? null;
  }

  if (!chore.dueDate) return null;

  const now = new Date();
  const today = now.toISOString().split("T")[0];
  const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000)
    .toISOString()
    .split("T")[0];

  const urgency = getUrgencyStatus(chore);
  if (urgency === "overdue") return "OVERDUE";

  if (chore.dueDate === today) {
    if (chore.dueTime) {
      const [hours, minutes] = chore.dueTime.split(":");
      const hour = parseInt(hours, 10);
      const period = hour >= 12 ? "PM" : "AM";
      const displayHour = hour % 12 || 12;
      return `TODAY â€¢ ${displayHour}:${minutes} ${period}`;
    }
    return "TODAY";
  }

  if (chore.dueDate === tomorrow) return "TOMORROW";

  // Format as date
  const date = new Date(chore.dueDate);
  return date.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric" });
}

/**
 * Get urgency badge variant
 */
export function getUrgencyVariant(
  urgency: UrgencyStatus
): "destructive" | "warning" | "secondary" | "default" {
  switch (urgency) {
    case "overdue":
      return "destructive";
    case "urgent":
      return "destructive";
    case "due-soon":
      return "warning";
    default:
      return "secondary";
  }
}
```

**Step 2: Commit**

```bash
git add src/components/chores/helpers.ts
git commit -m "feat(chores): add helper functions"
```

---

### Task 11: Create ChoreCard Component

**Files:**
- Create: `src/components/chores/components/chore-card.tsx`

**Step 1: Create the component file**

```typescript
"use client";

import { useState } from "react";
import { Check } from "lucide-react";
import { cn } from "@/lib/utils";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import type { IChoreWithAssignee } from "@/types/chore";
import {
  getUrgencyStatus,
  formatDueLabel,
  getUrgencyVariant,
} from "../helpers";
import { useChores } from "../contexts/chores-context";

interface ChoreCardProps {
  chore: IChoreWithAssignee;
}

export function ChoreCard({ chore }: ChoreCardProps) {
  const { completeChore } = useChores();
  const [isCompleting, setIsCompleting] = useState(false);
  const [isHovered, setIsHovered] = useState(false);

  const urgency = getUrgencyStatus(chore);
  const dueLabel = formatDueLabel(chore);
  const badgeVariant = getUrgencyVariant(urgency);

  const assignee = chore.assignedTo;
  const displayName = assignee?.displayName ?? assignee?.user.name ?? "Unassigned";
  const avatarColor = assignee?.avatarColor ?? "gray";

  const handleComplete = async () => {
    setIsCompleting(true);
    await completeChore(chore.id);
  };

  return (
    <div
      className={cn(
        "group relative flex items-center gap-4 rounded-xl border bg-card p-4 transition-all duration-200",
        isHovered && "border-primary shadow-sm",
        isCompleting && "animate-out slide-out-to-right fade-out duration-300"
      )}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      {/* Avatar */}
      <Avatar className="h-14 w-14 ring-2 ring-offset-2" style={{ "--ring-color": avatarColor } as React.CSSProperties}>
        <AvatarImage src={assignee?.user.image ?? undefined} alt={displayName} />
        <AvatarFallback style={{ backgroundColor: avatarColor }} className="text-white font-medium">
          {displayName.slice(0, 2).toUpperCase()}
        </AvatarFallback>
      </Avatar>

      {/* Content */}
      <div className="flex-1 min-w-0">
        <h3 className="font-semibold text-lg truncate">{chore.title}</h3>
        <div className="flex items-center gap-2 mt-1">
          {dueLabel && (
            <Badge variant={badgeVariant} className="text-xs font-bold uppercase">
              {dueLabel}
            </Badge>
          )}
          <span className="text-sm text-muted-foreground">{displayName}</span>
        </div>
      </div>

      {/* Check Button */}
      <Button
        variant="ghost"
        size="icon"
        className={cn(
          "h-12 w-12 rounded-full transition-all duration-200",
          "bg-muted hover:bg-primary hover:text-primary-foreground",
          "opacity-0 group-hover:opacity-100",
          isHovered && "opacity-100"
        )}
        onClick={handleComplete}
        disabled={isCompleting}
        aria-label={`Mark ${chore.title} as complete`}
      >
        <Check className="h-6 w-6" />
      </Button>
    </div>
  );
}
```

**Step 2: Commit**

```bash
git add src/components/chores/components/chore-card.tsx
git commit -m "feat(chores): add ChoreCard component"
```

---

### Task 12: Create ProgressCard Component

**Files:**
- Create: `src/components/chores/components/progress-card.tsx`

**Step 1: Create the component file**

```typescript
"use client";

import { Trophy } from "lucide-react";
import { Progress } from "@/components/ui/progress";
import { useChores } from "../contexts/chores-context";

export function ProgressCard() {
  const { progress } = useChores();

  // TODO: Implement actual streak tracking
  const streak = 12;

  return (
    <div className="rounded-xl border bg-card p-4">
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center gap-2">
          <Trophy className="h-5 w-5 text-primary" />
          <span className="font-semibold">Daily Streak: {streak} Days</span>
        </div>
        <span className="text-sm text-muted-foreground">
          {progress.completed}/{progress.total} Done
        </span>
      </div>
      <Progress value={progress.percentage} className="h-3" />
    </div>
  );
}
```

**Step 2: Commit**

```bash
git add src/components/chores/components/progress-card.tsx
git commit -m "feat(chores): add ProgressCard component"
```

---

### Task 13: Create FilterTabs Component

**Files:**
- Create: `src/components/chores/components/filter-tabs.tsx`

**Step 1: Create the component file**

```typescript
"use client";

import { cn } from "@/lib/utils";
import { useChores } from "../contexts/chores-context";
import type { ChoreViewFilter } from "@/types/chore";

const FILTERS: { value: ChoreViewFilter; label: string }[] = [
  { value: "all", label: "All Chores" },
  { value: "by-person", label: "By Person" },
  { value: "urgent", label: "Urgent" },
];

export function FilterTabs() {
  const { currentView, setCurrentView } = useChores();

  return (
    <div className="flex rounded-xl bg-muted p-1">
      {FILTERS.map((filter) => (
        <button
          key={filter.value}
          onClick={() => setCurrentView(filter.value)}
          className={cn(
            "flex-1 rounded-lg px-4 py-2 text-sm font-medium transition-colors",
            currentView === filter.value
              ? "bg-primary text-primary-foreground"
              : "text-muted-foreground hover:text-foreground"
          )}
        >
          {filter.label}
        </button>
      ))}
    </div>
  );
}
```

**Step 2: Commit**

```bash
git add src/components/chores/components/filter-tabs.tsx
git commit -m "feat(chores): add FilterTabs component"
```

---

### Task 14: Create ChoreList Views

**Files:**
- Create: `src/components/chores/views/all-chores-view.tsx`
- Create: `src/components/chores/views/by-person-view.tsx`
- Create: `src/components/chores/views/urgent-view.tsx`

**Step 1: Create AllChoresView**

```typescript
"use client";

import { useChores } from "../contexts/chores-context";
import { ChoreCard } from "../components/chore-card";
import { sortChores } from "../helpers";

export function AllChoresView() {
  const { chores } = useChores();
  const sortedChores = sortChores(chores);

  if (sortedChores.length === 0) {
    return (
      <div className="text-center py-12 text-muted-foreground">
        <p className="text-lg font-medium">All done! ðŸŽ‰</p>
        <p className="text-sm">No pending chores right now.</p>
      </div>
    );
  }

  return (
    <div className="space-y-3">
      {sortedChores.map((chore) => (
        <ChoreCard key={chore.id} chore={chore} />
      ))}
    </div>
  );
}
```

**Step 2: Create ByPersonView**

```typescript
"use client";

import { useChores } from "../contexts/chores-context";
import { ChoreCard } from "../components/chore-card";
import { groupChoresByAssignee, sortChores } from "../helpers";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { ScrollArea, ScrollBar } from "@/components/ui/scroll-area";

export function ByPersonView() {
  const { chores, members } = useChores();
  const grouped = groupChoresByAssignee(chores);

  return (
    <ScrollArea className="w-full">
      <div className="flex gap-4 pb-4">
        {members.map((member) => {
          const memberChores = grouped.get(member.id) ?? [];
          const sortedChores = sortChores(memberChores);
          const displayName = member.displayName ?? member.user.name;

          return (
            <div key={member.id} className="w-80 flex-shrink-0">
              {/* Column Header */}
              <div className="flex items-center gap-3 mb-4 px-2">
                <Avatar className="h-10 w-10">
                  <AvatarImage src={member.user.image ?? undefined} alt={displayName} />
                  <AvatarFallback style={{ backgroundColor: member.avatarColor ?? undefined }}>
                    {displayName.slice(0, 2).toUpperCase()}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <p className="font-semibold">{displayName}</p>
                  <p className="text-sm text-muted-foreground">
                    {sortedChores.length} chore{sortedChores.length !== 1 ? "s" : ""}
                  </p>
                </div>
              </div>

              {/* Chores */}
              <div className="space-y-3">
                {sortedChores.length === 0 ? (
                  <div className="text-center py-8 text-muted-foreground text-sm">
                    No chores assigned
                  </div>
                ) : (
                  sortedChores.map((chore) => (
                    <ChoreCard key={chore.id} chore={chore} />
                  ))
                )}
              </div>
            </div>
          );
        })}
      </div>
      <ScrollBar orientation="horizontal" />
    </ScrollArea>
  );
}
```

**Step 3: Create UrgentView**

```typescript
"use client";

import { AlertTriangle } from "lucide-react";
import { useChores } from "../contexts/chores-context";
import { ChoreCard } from "../components/chore-card";
import { getUrgentChores, sortChores } from "../helpers";

export function UrgentView() {
  const { chores } = useChores();
  const urgentChores = sortChores(getUrgentChores(chores));

  if (urgentChores.length === 0) {
    return (
      <div className="text-center py-12 text-muted-foreground">
        <AlertTriangle className="h-12 w-12 mx-auto mb-4 opacity-50" />
        <p className="text-lg font-medium">No urgent chores</p>
        <p className="text-sm">Everything is on track!</p>
      </div>
    );
  }

  return (
    <div className="space-y-3">
      {urgentChores.map((chore) => (
        <ChoreCard key={chore.id} chore={chore} />
      ))}
    </div>
  );
}
```

**Step 4: Commit**

```bash
git add src/components/chores/views/
git commit -m "feat(chores): add view components"
```

---

### Task 15: Create Main Chores Component

**Files:**
- Create: `src/components/chores/chores.tsx`

**Step 1: Create the main component**

```typescript
"use client";

import { useChores } from "./contexts/chores-context";
import { ProgressCard } from "./components/progress-card";
import { FilterTabs } from "./components/filter-tabs";
import { AllChoresView } from "./views/all-chores-view";
import { ByPersonView } from "./views/by-person-view";
import { UrgentView } from "./views/urgent-view";

interface ChoresProps {
  familyName: string;
}

export function Chores({ familyName }: ChoresProps) {
  const { currentView, isLoading } = useChores();

  // Get greeting based on time of day
  const hour = new Date().getHours();
  const greeting =
    hour < 12 ? "Good Morning" : hour < 18 ? "Good Afternoon" : "Good Evening";

  return (
    <div className="space-y-6">
      {/* Greeting */}
      <div>
        <h1 className="text-3xl font-bold">
          {greeting}, {familyName}!
        </h1>
        <p className="text-muted-foreground">Let&apos;s crush today&apos;s goals.</p>
      </div>

      {/* Progress */}
      <ProgressCard />

      {/* Filters */}
      <FilterTabs />

      {/* Chore List */}
      <div className={isLoading ? "opacity-50 pointer-events-none" : ""}>
        {currentView === "all" && <AllChoresView />}
        {currentView === "by-person" && <ByPersonView />}
        {currentView === "urgent" && <UrgentView />}
      </div>
    </div>
  );
}
```

**Step 2: Create index export**

Create `src/components/chores/index.tsx`:

```typescript
export { Chores } from "./chores";
export { ChoresProvider } from "./contexts/chores-context";
```

**Step 3: Commit**

```bash
git add src/components/chores/
git commit -m "feat(chores): add main Chores component"
```

---

## Phase 7: Page Integration

### Task 16: Create Chores Page

**Files:**
- Create: `src/app/[locale]/(app)/chores/page.tsx`

**Step 1: Create the page file**

```typescript
import { redirect } from "next/navigation";
import { headers } from "next/headers";
import { auth } from "@/server/auth";
import { getDefaultFamilyForUser } from "@/server/services/family-service";
import { getChoresForFamily, getChoreProgress } from "@/server/services/chore-service";
import { getFamilyMembers } from "@/server/services/family-service";
import { Chores, ChoresProvider } from "@/components/chores";

export default async function ChoresPage() {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session?.user) {
    redirect("/auth/sign-in");
  }

  const family = await getDefaultFamilyForUser(session.user.id);
  if (!family) {
    redirect("/families/create");
  }

  const [chores, progress, members] = await Promise.all([
    getChoresForFamily(family.id, { status: "pending" }),
    getChoreProgress(family.id),
    getFamilyMembers(family.id),
  ]);

  return (
    <div className="container max-w-4xl py-8">
      <ChoresProvider
        familyId={family.id}
        initialChores={chores}
        initialProgress={progress}
        members={members}
      >
        <Chores familyName={family.name} />
      </ChoresProvider>
    </div>
  );
}
```

**Step 2: Commit**

```bash
git add src/app/\[locale\]/\(app\)/chores/
git commit -m "feat(chores): add chores page"
```

---

### Task 17: Add Navigation Link

**Files:**
- Modify: `src/components/layout/sidebar.tsx` (or wherever navigation is defined)

**Step 1: Find navigation config and add chores link**

Add to navigation items:

```typescript
{
  href: "/chores",
  label: "Chores",
  icon: CheckSquare, // from lucide-react
}
```

**Step 2: Commit**

```bash
git add src/components/
git commit -m "feat(chores): add navigation link"
```

---

## Phase 8: Testing & Verification

### Task 18: Manual Testing

**Step 1: Start dev server**

Run: `pnpm dev`
Expected: Server starts on http://localhost:3000

**Step 2: Test database migration**

Run: `pnpm db:studio`
Expected: Drizzle Studio shows `chores` table

**Step 3: Test API endpoints**

Using the browser or curl:
- `GET /api/v1/families/{familyId}/chores` - should return empty array
- `POST /api/v1/families/{familyId}/chores` - create a test chore
- `GET /api/v1/families/{familyId}/chores/progress` - should return progress

**Step 4: Test UI**

Navigate to `/chores` and verify:
- Greeting displays correctly
- Progress card shows
- Filter tabs work
- Chore cards render (after adding test data)
- Completion works

**Step 5: Commit any fixes**

```bash
git add -A
git commit -m "fix(chores): address testing issues"
```

---

### Task 19: Add Translation Keys

**Files:**
- Modify: `messages/en.json`
- Modify: `messages/nl.json`

**Step 1: Add English translations**

Add to `messages/en.json`:

```json
{
  "chores": {
    "title": "Chores",
    "greeting": {
      "morning": "Good Morning",
      "afternoon": "Good Afternoon",
      "evening": "Good Evening"
    },
    "subtitle": "Let's crush today's goals.",
    "filters": {
      "all": "All Chores",
      "byPerson": "By Person",
      "urgent": "Urgent"
    },
    "progress": {
      "streak": "Daily Streak: {days} Days",
      "done": "{completed}/{total} Done"
    },
    "empty": {
      "all": "All done! No pending chores.",
      "urgent": "No urgent chores. Everything is on track!",
      "person": "No chores assigned"
    },
    "labels": {
      "overdue": "Overdue",
      "today": "Today",
      "tomorrow": "Tomorrow",
      "daily": "Daily",
      "weekly": "Weekly",
      "weekdays": "Weekdays",
      "weekend": "Weekend",
      "monthly": "Monthly"
    }
  }
}
```

**Step 2: Add Dutch translations**

Add to `messages/nl.json`:

```json
{
  "chores": {
    "title": "Klusjes",
    "greeting": {
      "morning": "Goedemorgen",
      "afternoon": "Goedemiddag",
      "evening": "Goedenavond"
    },
    "subtitle": "Laten we vandaag aan de slag gaan.",
    "filters": {
      "all": "Alle klusjes",
      "byPerson": "Per persoon",
      "urgent": "Dringend"
    },
    "progress": {
      "streak": "Dagelijkse reeks: {days} dagen",
      "done": "{completed}/{total} Klaar"
    },
    "empty": {
      "all": "Alles gedaan! Geen openstaande klusjes.",
      "urgent": "Geen dringende klusjes. Alles op schema!",
      "person": "Geen klusjes toegewezen"
    },
    "labels": {
      "overdue": "Te laat",
      "today": "Vandaag",
      "tomorrow": "Morgen",
      "daily": "Dagelijks",
      "weekly": "Wekelijks",
      "weekdays": "Weekdagen",
      "weekend": "Weekend",
      "monthly": "Maandelijks"
    }
  }
}
```

**Step 3: Commit**

```bash
git add messages/
git commit -m "feat(chores): add i18n translations"
```

---

## Summary

This plan covers the complete implementation of the chores feature:

| Phase | Tasks | Description |
|-------|-------|-------------|
| 1 | Task 1 | Database schema with Drizzle |
| 2 | Task 2 | TypeScript type definitions |
| 3 | Task 3 | Zod validation schemas |
| 4 | Task 4 | Service layer for DB operations |
| 5 | Tasks 5-8 | API routes (CRUD + completion + progress) |
| 6 | Tasks 9-15 | UI components (context, cards, views) |
| 7 | Tasks 16-17 | Page integration and navigation |
| 8 | Tasks 18-19 | Testing and translations |

**Deferred for future work:**
- Streak tracking (requires additional schema)
- Chore recurrence instance generation
- Management mode (create/edit/delete UI)
- Animations and transitions
- E2E tests

**Reference docs:**
- Design mockup: `docs/design/chores/chores-design-1.png`
- Feature spec: `docs/features/chores/spec.md`
- Data model: `docs/features/chores/data-model.md`
- UI spec: `docs/features/chores/ui.md`
